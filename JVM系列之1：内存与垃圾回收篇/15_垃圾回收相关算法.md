# 第15章 垃圾回收相关算法

## 1 标记阶段：引用计数算法

* 垃圾标记阶段：对象存活判断
  * 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<font color=blue>**需要区分出内存中哪些是存活对象，哪些是死亡的对象**</font>。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占的内存空间，因此这个过程我们可以称为<font color=blue>**垃圾标记阶段**</font>。
  * 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何存活对象继续引用时，就可以还盘为已经死亡。
  * 判断对象存活一般由两种方式：<font color=red>**引用计数算法**</font>和<font color=red>**可达性分析算法**</font>。

---

* 方式1：引用计数算法

  * 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整形的<font color=red>**引用计数器属性。用于记录对象被引用的情况**</font>。

  * 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

  * 优点：<font color=blue>**实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性**</font>。

  * 缺点：

    * 它需要单独的字段存储计数器，这样的做法增加了<font color=blue>**存储空间的开销**</font>。
    * 没每次赋值都需要更新计数器，伴随着加法和减法的操作，这增加了<font color=blue>**时间开销**</font>。
    * 引用计数器有一个严重的问题，即无法处理<font color=blue>**循环引用**</font>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

    <img src="images/270.png" alt="img" style="zoom:67%;" />

  * 代码示例

    ```java
    /**
     * -XX:+PrintGCDetails
     * 证明：java使用的不是引用计数算法
     */
    public class RefCountGC {
        // 这个成员属性唯一的作用就是占用一点内存
        private byte[] bigSize = new byte[5 * 1024 * 1024];  // 5MB
    
        Object reference = null;
    
        public static void main(String[] args) {
            RefCountGC obj1 = new RefCountGC();
            RefCountGC obj2 = new RefCountGC();
    
            obj1.reference = obj2;
            obj2.reference = obj1;
    
            obj1 = null;
            obj2 = null;
            // 显式的执行垃圾回收行为
            // 这里发生GC，obj1和obj2能否被回收？
            System.gc();
        }
    }
    ```

    如果采用循环引用会出现问题，如下图：

    <img src="images/271.png" alt="img" style="zoom:67%;" />

    **如果System.gc();被注释掉，输出结果如下**

    <img src="images/272.png" alt="img" style="zoom:100%;" />

    **如果System.gc();没被注释掉，输出结果如下**

    <img src="images/273.png" alt="img" style="zoom:100%;" />

---

* 小节
  * 引用计数算法，是很多语言的资源回收选择，例如隐人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。
  * 具体哪种最优是要看场景的，业界有大规模时间中仅保留引用技术机制，以提高吞吐量的尝试。
  * Java并没有选择引用计数，是因为其存在一个基本难题，也就是很难处理循环引用关系。
  * Python如何解决循环引用？
    * 手动解除：很好理解，就是在合适的实际，解除引用关系。
    * 使用弱引用weakref，weakref是Python提供的标准，只在解决循环引用。

## 2 标记阶段：可达性分析算法

* 方式二：可达性分析（或跟搜索算法、追踪性垃圾收集）

  * 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<font color=blue>**解决在引用计数算法中循环引用的问题，防止内存泄露的发生**</font>。

  * 相对于引用计数算法，这里的可达性分析就是<font color=red>**Java、C#**</font>选择的。这种类型的垃圾收集通常也叫做<font color=blue>**追踪性垃圾收集**</font>（Tracing Garbage Collection）。

  * 所谓“GC Roots”根集合就是一组必须活跃的引用。

  * 基本思路：

    * 可达性分析算法是以根集合（GC Roots）为起始点，按照从上至下的方式<font color=blue>**搜索被根对象集合所连接的目标是否可达**</font>。
    * 使用可达性分析算法后，内存中存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为<font color=red>**引用链（Reference Chain）**</font>。
    * 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。
    * 在可达性分析算法中，只有能被根对象集合直接或者间接连接的对象才是存活对象。

    <img src="images/274.png" alt="img" style="zoom:67%;" />

---

* 在Java语言中，GC Roots包括以下几类元素：

  * 虚拟机栈中引用的对象
    * 比如：各个线程被调用的方法中使用到的参数、局部变量等。
  * 本地方法栈JNI（通常说的本地方法）引用的对象
  * 方法区中静态属性引用的对象
    * 比如：Java类的引用类型静态变量
  * 方法区中常量引用的对象
    * 比如：字符串常量池（StringTable）里的引用
  * 所有被同步锁synchronized持有的对象
  * Java虚拟机内部的引用。
    * 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。
  * 反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

  <img src="images/275.png" alt="img" style="zoom:67%;" />

  * 除了这些固定的GC Roots集合以外，根据用户选择的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合，比如：分代收集和局部回收（Partial GC）。
    * 如果只针对Java堆中某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机字节的实现细节，更不是鼓励封闭的，这个区域的对象完全有可能被其他区域对象的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确定。

* 小技巧：
  * 由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那么它就是一个Root。

---

* 注意：
  * 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保证一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。
  * 这点也是导致GC进行时必须“Stop The World”的一个重要原因。
    * 即使是号称（几乎）不会发生停顿的CMS收集器中，<font color=red>**枚举根节点时也是必须要停顿的**</font>。

## 3 对象的finalization机制

142

## 4 MAT与JProfiler的GC Roots溯源



## 5 清除阶段：标记-清除算法



## 6 清除阶段：复制算法



## 7 清除阶段：标记-压缩算法



## 8 小节



## 9 分代收集算法



## 10 增量收集算法、分区算法